#!/usr/bin/env bash

set -euo pipefail

# BEGIN HELPERS

function guard__command_in_PATH() {
  for cmd in "$@"; do
    if ! command -v "$cmd" &>/dev/null; then
      echo "'$cmd' CLI not found in PATH." >&2
      exit 1
    fi
  done
}

function guard__is_git_repo() {
  if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    echo "Not inside a git repository." >&2
    exit 1
  fi
}

function guard__is_clean_repo() {
  test "$(git status --porcelain)" = "" || {
    echo "Dirty tree detected. Aborting." >&2
    exit 1
  }
}

function guard__has_github_remote() {
  if ! git remote -v | grep -q "github.com"; then
    echo "No remote with 'github.com' found." >&2
    exit 1
  fi
}

function get_current_branch() {
  git rev-parse --abbrev-ref HEAD
}

prompt() {
  [[ "$PROMPT_MODE" == true ]] && echo "$1" && exit 0
  return 0
}
# END HELPERS

# BEGIN WORKFLOWS

function wf_create_issue() {
  prompt "üìù Create a new issue:
- Opens the text editor with an issue template loaded.
- Here, you can write a description of the issue.
- You must save and exit the editor.
- Attempts to create an issue (using github cli).
- Finally, re-run this script from the 'main' branch to start working on the issue.
"
  gh issue create --assignee @me --editor
}

function _checkout_issue_branch() {
  local branches
  branches=$(gh issue develop --list "$1")
  if [[ -n "$branches" ]]; then
    git checkout "$(echo "$branches" | head -n1 | cut -f1)"
    return 0
  fi
  return 1
}

function wf_develop_issue() {
  prompt "üíª Work on an issue:
- You will be prompted to select an existing issue.
- The linked issue branch will be checked out
    - The branch will be created if needed.
- From this branch, you can make commits and pushes normally.
- Finally, rerun this script from the issue-branch to close the issue with a PR.
"
  issues=$(gh issue list --state open --json number,title,body)
  mapfile -t choices < <(echo "$issues" |
    jq -c '.[] | "#\(.number) \(.title) ¬¶ \(.body)"')
  for i in "${!choices[@]}"; do
    choices[i]=$(jq -r . <<<"${choices[$i]}")
  done
  if [[ ${#choices[@]} -eq 0 ]]; then
    echo "No open issues."
    exit 0
  fi

  selected=$(printf "%s\0" "${choices[@]}" | fzf \
    --read0 \
    --delimiter="¬¶" \
    --with-nth=1 \
    --prompt="Select a workflow: " \
    --height=65 --border \
    --preview="echo {2..}" \
    --preview-window=down:10:wrap)
  if [[ -z "$selected" ]]; then
    echo "No issue selected." >&2
    exit 1
  fi

  issue_number=$(echo "$selected" | head -n 1 | awk '{print $1}' | sed 's/#//g;s/ //g')

  tmpout=$(mktemp)
  gh issue develop --list "$issue_number" >"$tmpout"

  _checkout_issue_branch "$issue_number" ||
    gh issue develop "$issue_number" --checkout

  branch=$(get_current_branch)
  if [[ $branch == "main" ]]; then
    echo "Something went wrong, still on main branch." >&2
    exit 1
  fi
}

function wf_resolve_issue() {
  prompt "‚úÖ Resolve current issue:
- A PR will be opened from this issue branch to main.
- This PR will be merged and the current issue branch closed.
- You will go back to main. Re-run this from 'main'
    - to create issues / work on other issues.
    - OR to create a new release.
"
  gh pr create --assignee @me --fill
  gh pr merge --merge --delete-branch
}

function wf_prepare_release() {
  prompt "üß∞ Prepare for a release:
- Auto bump versions in files (but not tags).
- Creates (and checks out) a new release-branch.
- You can verify the changes, commit / push as normal.
- Finally, rerun the script from this release- branch and choose 'üöÄ Release!'
"
  if [[ -f Cargo.toml ]]; then
    guard__command_in_PATH cargo cargo-semver-checks release-plz
    echo "Running release-plz, this might take a while..."
    release-plz update
    new_version=$(cargo read-manifest | jq -r .version)
    git checkout -b "release-$new_version"
  fi
}

function wf_release() {
  prompt "üöÄ Release:
- A PR will be opened from this release-branch to main.
- This PR will be merged and the current release-branch closed.
- Finally, a tag is generated and pushed (to trigger CD actions).
"
  gh pr create --assignee @me --fill
  gh pr merge --merge --delete-branch
  if [[ -f Cargo.toml ]]; then
    guard__command_in_PATH cargo
    new_version=$(cargo read-manifest | jq -r .version)
    git tag -a "v$new_version" -m "Release v$new_version"
    git push origin "v$new_version"
  fi
}
# END WORKFLOWS

function select_workflow() {
  local -n wfs="$1"
  avail=()

  PROMPT_MODE=true
  for wf in "${wfs[@]}"; do
    avail+=("$("$wf")")
  done
  PROMPT_MODE=false

  selected=$(printf "%s\0" "${avail[@]}" |
    fzf \
      --read0 \
      --delimiter=":" \
      --with-nth=1 \
      --no-input \
      --height=13 --border \
      --preview="echo {2..}" \
      --preview-window=down:6:wrap)
  if [[ -z "$selected" ]]; then
    echo "No workflow selected." >&2
    exit 1
  fi

  idx=-1
  for i in "${!avail[@]}"; do
    if [[ "${avail[$i]}" == "$selected" ]]; then
      idx=$i
      break
    fi
  done

  echo "${wfs[idx]}"
}

main() {
  guard__command_in_PATH gh git
  guard__is_git_repo
  guard__is_clean_repo
  guard__has_github_remote
  guard__gh_is_authenticated

  branch=$(get_current_branch)

  workflows=()
  if [[ "$branch" == "main" ]]; then
    workflows+=(
      wf_create_issue
      wf_develop_issue
      wf_prepare_release
    )
  elif [[ "$branch" =~ ^[0-9]-* ]]; then
    workflows+=(wf_resolve_issue)
  elif [[ "$branch" =~ ^release-* ]]; then
    workflows+=(wf_release)
  else
    echo "No workflows available on current branch." >&2
    exit 1
  fi

  workflow=$(select_workflow workflows)

  PROMPT_MODE=false
  ("$workflow")
}

main "$@"
